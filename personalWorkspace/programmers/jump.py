# 효진이는 한번에 한칸 또는 2칸씩 뛸 수 있다.
# 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기서 1234567을 나눈 나머지
# 리턴하는 함수
'''
# 알고리즘 : 
일단 몇개 해볼까?
2 -> 2: (1,1) (2)
3 -> 3: (1,1,1) (2,1) (1,2)
4 -> 5: (1,1,1,1) (1,2,1) (1,1,2),(2,1,1) (2,2)
4인 경우 1111->1 와 112->3와 22->1 있다.  = 5
5인 경우 11111 (5!/5!) -> 1 1112 -> 4 122 -> 3 =1+4+3 = 8
6인 경우 111111(6!/6!) -> 1 11112 ->5 1122-> 6 222 = 1 = 1+5+6+1 = 13
7인 경우 1111111, 111112 11122 1222 = 1 + 6 + 10 + 4 = 21
음 오키
방법 1.
1. n을 2로 나눈다.
2. 2의 개수와 1의 개수가 몇개의 쌍으로 구성되는 지 찾는다.
3. facotiral(2의 개수+1의개수)/(factorial(2의개수)*factorial(1의 개수))
4. 위를 모든 경우의 수를 합하면 답이다.

생각해볼점 : 
경우의 수를 어떻게 나눌까?
6의 경우 6/2를 해보고 2가 3개이니까 2를 계속 쪼개서 만든다.
n인 경우 n/2를 해보고 2의 개수 : n/2-k + 1의 개수 : 2*k+n%2 

답을 보니 순서가 피보나치형식이다.
내 코드가 왜 틀렸을까?
'''

def factorial(n):
    ret = 1
    while(n!=0):
        ret*=n
        n-=1
    return ret

def solution(n):
    answer = 0
    k = 0
    new_list = []
    num_2=0
    while(num_2>=0):
        num_1 = n%2 + 2 * k
        num_2 = n//2 - k
        if num_2==-1:
            break
        new_list.append([num_1,num_2])
        k+=1
    for i in new_list:
        answer+= factorial(i[0]+i[1])/(factorial(i[0])*factorial(i[1]))
    if answer==0:
        answer=1
    print(f'n : {n}, answer : {answer%1234567}')

    return answer%1234567

testcase = [ i for i in range(1,20)]
for i in testcase:
    solution(i)